{"version":3,"file":"main.5761978b31c10233dbc3.js","mappings":";;;;;AAAoB;AACb;AACP;AACA;AACA;AACA;AACA,uDAAuD;AACvD;;AAEA,wBAAwB,QAAQ,OAAO;AACvC;AACA;AACA;AACA;;AAEA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;;AAEA,4BAA4B,QAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,QAAQ;AAChC,4BAA4B,QAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,QAAQ;AAChC,4BAA4B,QAAQ;AACpC;;AAEA,8DAA8D;;AAE9D;AACA;;AAEA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;;;AC7EO;AACP;AACA;AACA,2CAA2C;AAC3C,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,OAAO;AAChC,6BAA6B,OAAO;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,4BAA4B,OAAO;AACnC,gCAAgC,OAAO;AACvC,qCAAqC,yBAAyB;AAC9D,qCAAqC,2BAA2B;AAChE;AACA;AACA;AACA;AACA,iCAAiC,yBAAyB;AAC1D,iCAAiC,yBAAyB;AAC1D,iCAAiC,yBAAyB;AAC1D,iCAAiC,yBAAyB;AAC1D,iCAAiC,yBAAyB;AAC1D,iCAAiC,yBAAyB;AAC1D,iCAAiC,yBAAyB;AAC1D,iCAAiC,yBAAyB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC,4BAA4B,QAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;;ACxFO;AACP;AACA;AACA;AACA,YAAY,uBAAuB;AACnC;;ACLsC;AACV;AACrB;;AAEP,gBAAgB,SAAS;AACzB,2CAA2C,iCAAiC;AAC5E,yBAAyB;;AAEzB;AACA;AACA,mBAAmB,OAAO;AAC1B,kBAAkB,IAAI;AACtB,mBAAmB,OAAO;AAC1B,kBAAkB,IAAI;AACtB,mBAAmB,OAAO;AAC1B,kBAAkB,IAAI;AACtB,cAAc,IAAI;;AAElB;AACA;AACA;;AAEA,mCAAmC;AACnC,4BAA4B,gBAAgB;AAC5C,oDAAoD;AACpD;;AAEA,8EAA8E;AAC9E;AACA,uCAAuC;;AAEvC;AACA;AACA,2CAA2C,2BAA2B;AACtE;AACA,2CAA2C,2BAA2B;AACtE;AACA,2CAA2C,2BAA2B;AACtE;AACA,2CAA2C,2BAA2B;AACtE;AACA,mFAAmF;AACnF,qEAAqE;;AAErE,6BAA6B;AAC7B;AACA,+CAA+C,2BAA2B;AAC1E;AACA,+CAA+C,2BAA2B;AAC1E;AACA,kBAAkB;AAClB;AACA,+CAA+C,2BAA2B;AAC1E;AACA,+CAA+C,2BAA2B;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,mDAAmD;AACvE;AACA;;AAEA,2EAA2E;;AAE3E;AACA;AACA,4BAA4B,OAAO;AACnC,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA,2DAA2D,6BAA6B;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA,2CAA2C,+CAA+C;AAC1F;AACA;AACA,4BAA4B,OAAO;AACnC,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,4BAA4B,SAAS;AACrC;AACA;AACA;AACA;AACA,0BAA0B,aAAa;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA,4DAA4D;AAC5D;AACA;AACA,oBAAoB,aAAa;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;;ACpLmC;;AAE5B;AACP;AACA,iBAAiB,SAAS;AAC1B,aAAa,SAAS;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,cAAc;AACnC,qBAAqB,cAAc;AACnC,iBAAiB,UAAU;AAC3B;AACA;AACA;AACA;;AClCyB;AACzB;;AAEe;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,OAAO;AAC3B,uBAAuB,UAAU;AACjC,sBAAsB,wCAAwC;AAC9D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;ACnCyC;AACJ;AACoB;AACrC;;AAEpB;AACA;AACA;AACA,cAAc,WAAW,eAAe;AACxC;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,uBAAuB;AACvB,0BAA0B,eAAe,IAAI;;AAE7C;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;;AAEA,WAAW,OAAO;;AAElB;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA,SAAS;AACT,KAAK;;AAEL;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,wBAAwB,QAAQ;AAChC,2CAA2C;;AAE3C;;AAEA,kCAAkC;AAClC;AACA,uBAAuB,QAAQ;AAC/B,4BAA4B,QAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B,4BAA4B,QAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA,kDAAkD,eAAe,QAAQ;AACzE,mCAAmC,eAAe,GAAG;AACrD,6FAA6F;AAC7F;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,UAAU;AACV,6DAA6D,eAAe;AAC5E;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,WAAW,cAAc;AAC3C,iCAAiC;;AAEjC;AACA,mBAAmB,QAAQ;AAC3B,wBAAwB,QAAQ;AAChC,6DAA6D,oBAAoB;AACjF;;AAEA;AACA;AACA,2CAA2C,eAAe,GAAG;;AAE7D,6BAA6B;AAC7B;AACA;;AAEA,2CAA2C;;AAE3C,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA,2BAA2B;AAC3B;AACA;AACA,SAAS;AACT;;AAEA;AACA,4CAA4C;AAC5C;;AAEA,uBAAuB,QAAQ;AAC/B,4BAA4B,QAAQ;AACpC;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,QAAQ;AAC3B,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC","sources":["webpack://battleship/./src/DOM/board/board.js","webpack://battleship/./src/Logic/gameBoard.js","webpack://battleship/./src/Logic/ship.js","webpack://battleship/./src/Logic/player.js","webpack://battleship/./src/Logic/game.js","webpack://battleship/./src/DOM/shipSelection/shipSelect.js","webpack://battleship/./src/DOM/index.js"],"sourcesContent":["import './board.css'\nexport const createBoard = (div) => {\n    // Dom creation\n    let arr = Array.from(Array(10), ()=> []);\n        const boardDiv = div;\n        boardDiv.classList.add('board');\n        const nothing = document.createElement('div'); // Empty square at top left\n        boardDiv.append(nothing)\n\n        for (let i = 0; i < 10; i++) { // Indexes\n            const index = document.createElement('div');\n            index.textContent = i+1;\n            boardDiv.append(index)\n        }\n\n        for (let i = 0; i < 10; i++) {\n            // Indexes\n            const index = document.createElement('div');\n            index.textContent = String.fromCharCode(('A'.charCodeAt() + i));\n            boardDiv.append(index); \n\n            for (let k = 0; k < 10; k++) {\n                const square = document.createElement('button');\n                square.classList.add('boardSquare');\n                arr[i][k] = square;\n                boardDiv.append(square);\n            }\n        }\n\n    // Enable all squares that are not a ship\n    const enableAll = () =>{\n        for (let i = 0; i < 10; i++)\n            for (let k = 0; k < 10; k++){    \n                if(arr[i][k].className.includes(\"playerShip\"))\n                    arr[i][k].disabled = true;    \n                else\n                    arr[i][k].disabled = false;   \n            }\n    }\n\n    // Enable squares based on previous user inputs\n    const enableStack = (stack, isDone) => {\n        if(!stack.length){  \n            enableAll();\n            return;\n        }\n\n        // disable all at first\n        for (let i = 0; i < 10; i++) \n            for (let k = 0; k < 10; k++)\n                arr[i][k].disabled = true;   \n\n        arr[stack.at(-1).x][stack.at(-1).y].disabled = false; // Enable current input\n\n        if(isDone) // If user has put all the parts of the ship, don't let him continue\n            return;\n\n        // Both happen if user only inputs 1 square\n        if(stack[0].y === stack.at(-1).y){ // If user chose to go vertically\n            if(stack.at(-1).x >= stack[0].x)\n                arr[Math.min(stack.at(-1).x+1, 9)][stack.at(-1).y].disabled = false;\n            if(stack.at(-1).x <= stack[0].x)\n                arr[Math.max(stack.at(-1).x-1, 0)][stack.at(-1).y].disabled = false;\n        }\n        if(stack[0].x === stack.at(-1).x){ // If user chose to go horizontally\n            if(stack.at(-1).y >= stack[0].y)\n                arr[stack.at(-1).x][Math.min(stack.at(-1).y+1, 9)].disabled = false;\n            if(stack.at(-1).y <= stack[0].y)\n                arr[stack.at(-1).x][Math.max(stack.at(-1).y-1, 0)].disabled = false;\n        }\n    }\n\n    return {\n        enableAll,\n        enableStack,\n        get arr(){return arr}\n    }\n}\n\n","export const gameBoard = () =>{\n    // Initialize board\n    let board = Array.from(Array(10), ()=> {\n        return Array.from(Array(10), ()=>{})\n    });\n    // Initialize counter that tracks how many ships are alive on the board\n    let counter = 0;\n    const checkValidity = (ship, coor) => {\n        // Check if out of bounds\n        if(outOfBounds(coor))\n            return false;\n        // Runs on adjacent coordinates\n        for (let i = -1; i < 2; i++) {\n            for (let k = -1; k < 2; k++){\n                const curr = board[coor.x+i] ? board[coor.x+i][coor.y+k] : null;\n                // If spot is out of bounds or\n                if(curr){\n                    /* Checks if \n                        1.coordinates are not already occupied or diagonally adjacent to an occupied spot.\n                        2.coordinates are adjacent to a different ship\n                    */\n                    if(((i === 0 && k === 0) || (i !== 0 && k !== 0)) || curr !== ship)\n                        return false;\n                }\n            }        \n        }\n        return true;\n    }\n    const outOfBounds = (coor) => (coor.x > 9 || coor.x < 0 || coor.y > 9 || coor.y < 0);\n\n    const removeShip = (coor) => {\n        if(outOfBounds(coor))\n            return false;\n        let res = board[coor.x][coor.y];\n        board[coor.x][coor.y] = null;\n        return res; // Return the ship that was removed in order to put it back in the player's hands\n    };\n    \n    const placeShip = (ship, coor) => {\n        if(ship && checkValidity(ship, coor)){\n            board[coor.x][coor.y] = ship;\n            return true;\n        }\n        return false;\n    }\n    const isDestroyed = () => counter === 10;\n    \n    const receiveAttack = (coor) =>{\n        if(board[coor.x][coor.y]){\n            let checks = []; // matrix of checked squares squares\n            board[coor.x][coor.y].hit();\n            // If hit, all diagonal adjacencies are also known to not be occupied\n            for(let i = -1; i < 3; i += 2)\n                for(let k = -1; k < 3; k += 2)\n                    if(!outOfBounds({x: coor.x+i, y: coor.y+k}))\n                        checks.push({x: coor.x+i, y: coor.y + k});\n                    \n            if(board[coor.x][coor.y].isSunk()){   \n                counter++;\n                // If ship is sunk, you can also be sure that all horizontal and vertical adjacent squares are also checked \n                if(!outOfBounds({x: coor.x, y: coor.y + 1}) && !board[coor.x][coor.y+1])\n                    checks.push({x: coor.x, y: coor.y + 1});\n                if(!outOfBounds({x: coor.x, y: coor.y - 1}) && !board[coor.x][coor.y-1])\n                    checks.push({x: coor.x, y: coor.y - 1});\n                if(!outOfBounds({x: coor.x - 1, y: coor.y}) && !board[coor.x-1][coor.y])\n                    checks.push({x: coor.x - 1, y: coor.y});\n                if(!outOfBounds({x: coor.x + 1, y: coor.y}) && !board[coor.x+1][coor.y])\n                    checks.push({x: coor.x + 1, y: coor.y});\n            }\n            checks.unshift(coor);\n            return checks;\n        }\n        return coor;\n    }\n    const clear = () =>{\n        let arr = [];\n        for (let i = 0; i < 10; i++) {\n            for (let k = 0; k < 10; k++) {\n                if(board[i][k]) // If there's a ship, store it to put it back in the player's hands\n                    arr.push(board[i][k])\n                board[i][k] = null;\n            }\n        }\n        counter = 0;\n        return arr;\n    }\n    \n    return {placeShip, removeShip, receiveAttack, isDestroyed, clear}\n}","export const ship = (len) => {\n    let numOfTimesHit = 0;\n    const hit = () => numOfTimesHit++;\n    const isSunk = () => numOfTimesHit >= len;\n    return {hit, isSunk, get len(){return len}}\n}","import {gameBoard} from \"./gameBoard\"; \nimport {ship} from \"./ship\";\nexport const newPlayer = () =>{\n\n    let board = gameBoard();\n    let moves = Array.from(Array(10),()=> {return new Array(10).fill(false)});\n    let prevAndFuture = {prev: null, future: []};\n\n    // Initialize ships to be taken \n    let ships = new Map();  \n    for(let i = 0; i < 4; i++)\n        ships.set(ship(1), 1);\n    for(let i = 0; i < 3; i++)\n        ships.set(ship(2), 2);\n    for(let i = 0; i < 2; i++)\n        ships.set(ship(3), 3);\n    ships.set(ship(4), 4);\n\n    // If theres no coor input let the computer play\n    const attack = (enemy, coor = null) => {\n        let res = enemy.board.receiveAttack(coor??generateAttack())\n\n        if(Array.isArray(res)){    // If res is an array it means the attack hit a ship\n            for (let i = 1; i < res.length; i++) \n                moves[res[i].x][res[i].y] = true;   // remember all that was checked\n        }   \n\n        if(!coor && Array.isArray(res) && prevAndFuture.future.length === 0){ // If the attack was automatic, a hit, and the first hit in the chain\n            prevAndFuture.prev = res[0] // remember the first hit\n            prevAndFuture.future = []; // Initialize future attacks stack\n\n            // Try all directions\n            if(res[0].y+1 <= 9)\n                prevAndFuture.future.push({x: res[0].x, y: res[0].y+1})\n            if(res[0].y-1 >= 0)\n                prevAndFuture.future.push({x: res[0].x, y: res[0].y-1})\n            if(res[0].x+1 <= 9)\n                prevAndFuture.future.push({x: res[0].x+1, y: res[0].y})\n            if(res[0].x-1 >= 0)\n                prevAndFuture.future.push({x: res[0].x-1, y: res[0].y}) \n        }\n        else if(!coor && Array.isArray(res) && prevAndFuture.future.length !== 0){ // If attack was automatic, a hit, and not the first hit in the chain\n            let dir = res[0].x === prevAndFuture.prev.x ? 'x' : 'y'; // Check direction\n\n            if(dir === 'x'){ // Go horizontally\n                if(res[0].x+1 <= 9)\n                    prevAndFuture.future.push({x: res[0].x+1, y: res[0].y})\n                if(res[0].x-1 >= 0)\n                    prevAndFuture.future.push({x: res[0].x-1, y: res[0].y}) \n            }\n            else{ // Go vertically\n                if(res[0].y+1 <= 9)\n                    prevAndFuture.future.push({x: res[0].x, y: res[0].y+1})\n                if(res[0].y-1 >= 0)\n                    prevAndFuture.future.push({x: res[0].x, y: res[0].y-1})                \n            }\n        }\n        return res;\n    }; \n    \n    const takeShip = (len) =>{\n        for(const [k, v] of ships){\n            if(k.len === len && v !== 0){    \n                ships.set(k, v-1);\n                return k;\n            }\n        }\n        return null;\n    }\n\n    const returnShip = (ship = null) => { // If ship is null return all the ships from the board to the player\n        if(ship) \n            ships.set(ship, ships.get(ship)+1)\n        else\n            board.clear().forEach(s=>ships.set(s, s.len))\n    };\n\n    //Checks if game is ready to start\n    const isReady = ()=> {\n        for(const v of ships.values())\n            if(v)\n                return false;\n        return true;\n    }\n\n    const generateAttack =  () =>{\n        let move = prevAndFuture.future.pop(); // Take a move from the smart stack\n        let rndX = move ? move.x : ~~(Math.random()*10), rndY = move ? move.y : ~~(Math.random()*10);\n        // continue requesting coordinates until you hit one that wasn't attacked previously\n        while(moves[rndX][rndY]){    \n            move = prevAndFuture.future.pop();\n            rndX = move ? move.x : ~~(Math.random()*10), rndY = move ? move.y : ~~(Math.random()*10);\n        }\n        moves[rndX][rndY] = true;\n        return {x: rndX, y: rndY}\n    }\n    // n - ships to place, arr - the entire board marked by which kind of ship is on a spot\n    const generatePlacement = (n = [1, 1, 1, 1, 2, 2, 2, 3, 3, 4], arr = Array.from(Array(10), ()=> new Array(10).fill(0))) =>{\n        // If n equals 0 it means we are done with placing ships :)\n        if(n.length === 0)  \n            return arr;\n\n        let len = n.pop();\n        let coor = {x: ~~(Math.random()*10), y: ~~(Math.random()*10)}; // Get random coordinates\n        if(arr[coor.x][coor.y] !== 0) // If coordinate already occupied, try again\n            return generatePlacement([...n, len], arr);\n\n        const inBounds = (x, y) => (x >= 0 && x <= 9 && y >= 0 && y <= 9); // Bounds check\n\n        if(len === 1) // Special case for len === 1 because the diagonals do not fill all of the surroundings\n        {\n            for(let j = -1; j < 2; j++)\n                for(let k = -1; k < 2; k++)\n                    if(inBounds(coor.x + j, coor.y+k))\n                    {    \n                        if(j === 0&& k === 0)\n                        {\n                            board.placeShip(takeShip(len),{x: coor.x + j, y: coor.y + k});\n                            arr[coor.x+j][coor.y+k] = len;\n                        }\n                        else\n                            arr[coor.x+j][coor.y+k] = -1;      \n                    }\n            return generatePlacement(n, arr);\n        }\n        let vector = checkVector(coor, len, arr); // call checkVector to randomly decide which direction to go\n\n        // If vector is empty, that means theres no place for the ship we want to place, therefore try again\n        if(vector === undefined) \n            return generatePlacement([...n, len], arr);\n        \n        // All of this last section is putting the result and also not allowing ships around it\n        // Mark the place at the start on the opposite direction of the vector \n        if(inBounds(coor.x - 1*vector.x, coor.y - 1*vector.y))\n            arr[coor.x - 1*vector.x][coor.y - 1*vector.y] = -1;\n            \n        for (let i = 0; i < len; i++)\n        {    \n            board.placeShip(takeShip(len),{x: coor.x + i*vector.x, y: coor.y + i*vector.y});\n            arr[coor.x + i*vector.x][coor.y + i*vector.y] = len;\n            // Diagonals adjacencies \n            for(let j = -1; j < 2; j += 2)\n                for(let k = -1; k < 2; k += 2)\n                    if(inBounds(coor.x + j + i*vector.x, coor.y + k + i*vector.y))\n                        arr[coor.x + j + i*vector.x][coor.y + k + i*vector.y] = -1;\n        }\n        // Mark the place at the end on the same direction of the vector \n        if(inBounds(coor.x + len*vector.x, coor.y + len*vector.y))\n            arr[coor.x + len*vector.x][coor.y + len*vector.y] = -1;\n\n        return generatePlacement(n, arr);\n    }\n\n    const checkVector = (coor, len, arr) =>{\n        let options = [];\n        // lr - left/right, ud - up/down\n        let checkDirection = (lr, ud) =>{\n            for (let i = 0; i < len; i++) {\n                let spot = arr[coor.x + (i*lr)]?arr[coor.x + (i*lr)][coor.y + (i*ud)]:null;\n                if(spot !== 0)\n                    return;\n            }\n            options.push({x: lr, y: ud})\n        }\n        // All directions check;\n        checkDirection(0, 1)\n        checkDirection(0, -1)\n        checkDirection(-1, 0)\n        checkDirection(1, 0)\n\n        return options[~~(Math.random() * options.length)]; // Get a random direction from the available options\n    }\n    return {\n        get board(){return board}, \n        attack,\n        takeShip,\n        generatePlacement, \n        returnShip,\n        isReady\n    }\n}","import {newPlayer} from \"./player\";\n\nexport const newGame = () =>{\n    let status = 'placing';\n    let player = newPlayer();\n    let ai = newPlayer();\n\n    const start = () =>{\n        if(!player.isReady()){\n            return false;\n        }\n        status = 'playing'\n        return true;\n    }\n\n    const isFinished = () =>{\n        if(ai.board.isDestroyed()){\n            status = 'won';\n            return true;\n        }\n        if(player.board.isDestroyed()){\n            status = 'lost';\n            return true;\n        }\n        return false;\n    }\n\n    return {\n        get status(){return status}, \n        get player(){return player}, \n        get ai(){return ai},\n        start,\n        isFinished\n    }\n}","import './shipSelect.css'\nconst div = document.getElementById('extra-space');\n\nexport default function createSelection(){\n    while(div.firstChild) // Delete previous content of div\n        div.removeChild(div.firstChild);\n    div.textContent = '';\n    div.className = ''\n\n    div.classList.add('ships');    \n    let arr = [];\n    for (let i = 4; i > 0; i--) \n        for(let k = 0; k <= 4-i; k++)\n            arr.push({radio: createShip(i), len: i, stack: []});  \n    return arr;\n}\n\nfunction createShip(len){\n    const label = document.createElement('label');\n    label.for = 'ship' + len;\n    const radio = document.createElement('input');\n    radio.type = 'radio';\n    radio.name = 'ship';\n    label.append(radio);\n\n    for(let i = 0; i < len; i++){\n        const square = document.createElement('div');\n        square.classList.add('shipPiece')\n        square.classList.add('playerShip');\n        label.append(square);\n    }\n\n    div.append(label);\n\n    return radio;\n}","import {createBoard} from './board/board'\nimport {newGame} from '../Logic/game'\nimport createSelection from './shipSelection/shipSelect';\nimport './style.css'\n\n// All needed declarations\nconst playerBoard = document.getElementById('player-board');\nconst btnsDiv = document.getElementById('btns-div');\nconst board = createBoard(playerBoard); // Player's DOM board\nlet game;\nconst startBtn =document.getElementById('start');\nconst extraBoard = document.getElementById('extra-space')\n\n\n// Creation of clear and random buttons\nconst rndBtn = document.createElement('button');\nrndBtn.classList.add('ctrl-btn');\nrndBtn.textContent = 'Random';\nconst clrBtn = document.createElement('button');\nclrBtn.classList.add('ctrl-btn');\nclrBtn.textContent = 'Clear';\n\n// Call to initialize on page load\ninit();\n\nfunction init(){\n    transitionClear(); // Clear what was before (if there was anything)\n    const shipSelectArr = createSelection(); // DOM radio buttons creation\n\n    // Control buttons\n    btnsDiv.append(rndBtn);\n    btnsDiv.append(clrBtn);\n    clrBtn.click(); // Clear the player's board\n    // Turn start button back to initial state\n    startBtn.textContent = 'Start';\n    startBtn.style.color = 'white';\n\n    game = newGame(); \n\n    let currSelect;\n    // Ship taking events\n    shipSelectArr.forEach((s) => {\n        s.radio.addEventListener('change', ()=>{\n            currSelect = s; // Save the current radio button selected\n            board.enableStack(currSelect.stack, currSelect.len === currSelect.stack.length);\n        })\n    });\n\n    // Make a radio button automatically selected at page load\n    shipSelectArr[0].radio.click();\n    // Board placing events\n    for(let x = 0; x < 10; x++)\n        for (let y = 0; y < 10; y++) \n            board.arr[x][y].onclick = ()=>{placeShipOnBoard(x, y, currSelect)};\n\n    rndBtn.addEventListener('click', ()=>{\n\n        game.player.returnShip(); // Return all ships that were previously taken (no parameters = all)   \n        let arr = game.player.generatePlacement();\n        for(let x = 0; x < 10; x++)\n            for (let y = 0; y < 10; y++) \n            {    \n                if(arr[x][y] > 0)\n                    board.arr[x][y].classList.add('playerShip');\n                else\n                    board.arr[x][y].classList.remove('playerShip');\n                board.arr[x][y].disabled = true;\n            }\n        shipSelectArr.forEach(s=> s.radio.disabled = true)\n    })\n        \n    clrBtn.addEventListener('click', ()=>{\n        game.player.returnShip();\n        for(let x = 0; x < 10; x++)\n            for (let y = 0; y < 10; y++) {\n                board.arr[x][y].classList.remove('playerShip');\n                board.arr[x][y].textContent = '';\n                board.arr[x][y].disabled = false;\n            }\n        shipSelectArr[0].radio.click(); \n        shipSelectArr.forEach(s=> s.radio.disabled = false)\n    })\n}\n\n// function to place ships on the board in the DOM while also synchronizing the logic\nfunction placeShipOnBoard(x, y, currSelect){\n    let currShip;\n    if(board.arr[x][y].classList.toggle('playerShip')){ // If placing a ship\n        currShip = game.player.takeShip(currSelect.len); \n        \n        if(game.player.board.placeShip(currShip, {'x': x, 'y': y})){     //If placed a ship successfully\n            currSelect.stack.push({'x': x, 'y': y}); // Add placement to the memory stack\n            board.enableStack(currSelect.stack, currSelect.len === currSelect.stack.length); // Enable appropriate squares\n        }\n        else{ // If placement failed give back the ship\n            board.arr[x][y].classList.toggle('playerShip');\n            game.player.returnShip(currShip);\n        }\n    }\n    else{ // If removing a ship\n        game.player.returnShip(game.player.board.removeShip({'x': x, 'y': y}));\n        currSelect.stack.pop();\n        board.enableStack(currSelect.stack, currSelect.len === currSelect.stack.length);\n    }\n}\n\nfunction startGame() {\n    transitionClear();\n    // Remove unnecessary buttons\n    btnsDiv.removeChild(rndBtn);\n    btnsDiv.removeChild(clrBtn);\n    startBtn.textContent = 'Restart';\n\n    let aiBoard = createBoard(extraBoard); // Ai's DOM board\n    game.ai.generatePlacement(); // Generate random placements\n\n    // Event listeners\n    for(let x = 0; x < 10; x++)\n        for (let y = 0; y < 10; y++) \n            aiBoard.arr[x][y].addEventListener('click', ()=>{turn(x, y, aiBoard)});\n}\n\n// initiates a turn (1 attack for each if no hits)\nfunction turn(x, y, aiBoard){\n    let res = game.player.attack(game.ai, {'x': x, 'y': y}); // Let player attack first\n\n    if(!Array.isArray(res)){ // If missed\n        aiBoard.arr[x][y].textContent = '✕';\n        aiBoard.arr[x][y].disabled = true;\n\n        res = game.ai.attack(game.player); // Ai's turn\n\n        while(Array.isArray(res)){ // Let Ai play while he keeps hitting\n            board.arr[res[0].x][res[0].y].textContent = '✕';\n            board.arr[res[0].x][res[0].y].disabled = true;\n            res = game.ai.attack(game.player);\n        }   \n        board.arr[res.x][res.y].textContent = '✕';\n        board.arr[res.x][res.y].disabled = true;   \n    }\n    else{ // If hit\n        aiBoard.arr[x][y].classList.add('aiShip') // Reveal ship\n\n        res.forEach(coor=>{game // Mark surrounding as also checked\n            aiBoard.arr[coor.x][coor.y].textContent = '✕';\n            aiBoard.arr[coor.x][coor.y].disabled = true;\n        })\n    }\n\n    if(game.isFinished()){\n        startBtn.textContent = game.status; // Update status\n        startBtn.style.color = game.status === 'won' ? 'green' : 'red';\n\n        for(let x = 0; x < 10; x++)\n            for (let y = 0; y < 10; y++) \n                aiBoard.arr[x][y].disabled = true;\n    }\n}\n\n// Clear placing events and the extra div\nfunction transitionClear(){   \n    for(let x = 0; x < 10; x++)\n        for (let y = 0; y < 10; y++) {    \n            board.arr[x][y].disabled = true;\n            board.arr[x][y].removeAttribute('onclick');\n        }\n    while(extraBoard.firstChild)\n        extraBoard.removeChild(extraBoard.firstChild)\n    extraBoard.className = '';\n}\n\n// Control buttons event listeners\n\nstartBtn.addEventListener('click', ()=>{\n    if(game.status === 'placing'){    \n        if(game.start())\n            startGame();\n    }\n    else\n        init();\n})\n\n\n"],"names":[],"sourceRoot":""}